import os
from aqua.util import dump_yaml, load_yaml
from aqua.logger import log_configure
from aqua.util import ConfigPath
"""
for timeseries we need frequency mon/ann
for other diagnostics we don't need the frequency 
"""

def create_catalog_entry(parts_dict: dict = None, outdir: str = None, driver: str = 'netcdf'):


    catalog = parts_dict['catalog']
    model = parts_dict['model']
    exp = parts_dict['exp']
    diagnostic_name = parts_dict['diagnostic_name']
    realization = parts_dict['realization']

    parts_dict.update({parts_dict['var']: "*"})
    configpath = ConfigPath(catalog=catalog)
    configdir = configpath.configdir
    # find the catalog of the experiment and load it
    catalogfile = os.path.join(configdir, 'catalogs', catalog, 'catalog', model, exp + '.yaml')
    cat_file = load_yaml(catalogfile)
    
    print(catalogfile)
    print(cat_file)

    entry_name = f'aqua-{diagnostic_name}'
    
    # source_grid_name
    sgn = 'null'

    if entry_name in cat_file['sources']:
        catblock = cat_file['sources'][entry_name]
    else:
        catblock = None

    # Remove None values
    parts = [str(value) for value in parts_dict.values() if value is not None]

    # Join all parts to product filename
    filename = '.'.join(parts) + ".nc"

    # to create folder name
    _parts = _parts = [catalog, model, exp, realization] 
    folder = os.path.join(*[p for p in _parts if p])

    urlpath = os.path.join(outdir, folder, filename)
    urlpath = replace_intake_vars(catalog=catalog, path=urlpath)

    if catblock is None:
        # if the entry is not there, define the block to be uploaded into the catalog
        catblock = {
            'driver': driver,
            'description': f'AQUA {driver} data',
            'args': {
                'urlpath': urlpath,
                'chunks': {},
            },
            'metadata': {
                'source_grid_name': source_grid_name,
            }
        }
    else:
        # if the entry is there, we just update the urlpath
        catblock['args']['urlpath'] = urlpath

    if driver == 'netcdf':
        catblock['args']['xarray_kwargs'] = {
            'decode_times': True,
            'combine': 'by_coords'
        }

        catblock = replace_urlpath_jinja(catblock, parts_dict['diagnostic_product'], 'diagnostic_product')
        catblock = replace_urlpath_jinja(catblock, realization, 'realization')

        # here pop all the names used above in the url...
        parts_dict.pop({parts_dict['diagnostic_name']})
       
        for key in extra_keys:
             value = extra_keys[key] if key in extra_keys else None
             if value is not None:
                catblock = replace_urlpath_jinja(catblock, value, key)
    
    cat_file['sources'][entry_name] = catblock

    # dump the update file 
    dump_yaml(outfile=catalogfile, cfg=cat_file)

    return catblock # using this in the tests

def replace_urlpath_jinja(block, value, name):
    """
    Replace the urlpath in the catalog entry with the given jinja parameter and
    add the parameter to the parameters block

    Args:
        block (dict): The catalog entry generated by `catalog_entry_details' to be updated
        value (str): The value to replace in the urlpath (e.g., 'r1', 'global', 'mean')
        name (str): The name of the parameter to add to the parameters block
                    and to be used in the urlpath (e.g., 'realization', 'region', 'stat')
    """
    if not value:
        return block
    # this loop is a bit tricky but is made to ensure that the right value is replaced
    for character in ['_', '/']:
        block['args']['urlpath'] = block['args']['urlpath'].replace(
            character + value + character, character + "{{" + name + "}}" + character)
    if 'parameters' not in block:
        block['parameters'] = {}
    if name not in block['parameters']:
        block['parameters'][name] = {}
        block['parameters'][name]['description'] = f"Parameter {name} for the LRA"
        block['parameters'][name]['default'] = value
        block['parameters'][name]['type'] = 'str'
        block['parameters'][name]['allowed'] = [value]
    else:
        if value not in block['parameters'][name]['allowed']:
            block['parameters'][name]['allowed'].append(value)

    return block

def get_urlpath(block):
    """
    Get the urlpath for the catalog entry
    """
    return block['args']['urlpath']

def replace_intake_vars(path, catalog=None):
    """
    Replace the intake jinja vars into a string for a predefined catalog

    Args:
        catalog:  the catalog name where the intake vars must be read
        path: the original path that you want to update with the intake variables
    """

    # We exploit of configurerto get info on intake_vars so that we can replace them in the urlpath
    Configurer = ConfigPath(catalog=catalog)
    _, intake_vars = Configurer.get_machine_info()

    # loop on available intake_vars, replace them in the urlpath
    for name in intake_vars.keys():
        replacepath = intake_vars[name]
        if replacepath is not None and replacepath in path:
            # quotes used to ensure that then you can read the source
            path = path.replace(replacepath, "{{ " + name + " }}")

    return path
